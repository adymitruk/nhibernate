<!-- <!DOCTYPE chapter SYSTEM "../../docbook-xml/docbookx.dtd"> -->
<chapter id="NHibernateEg.Tutorial1A">
	<title>NHibernateEg.Tutorial1A</title>


	<abstract id="NHibernateEg.Tutorial1A-abstract">
		<title>Overview</title>

		<para>Here you will discover how to set up NHibernate and use it for basic operations.</para>
		<para>You should have all the <link linkend="Preface-Requirements">requirements</link> and the <link linkend="Preface-GetNHibernateEg">source code</link> (or at least the binary files).</para>
	</abstract>


	<section id="NHibernateEg.Tutorial1A-Shop">
		<title>The Shop (+ Order)</title>

		<para>The application of this tutorial mimics a (very simple) shop. The main (and only) managed class is the <classname>Order</classname>.</para>

		<para>
			<classname>Order</classname> is a class which has an <emphasis role="strong">identifier</emphasis> that makes it unique. Its properties are:
			<itemizedlist>
				<listitem><para>A <emphasis role="strong">Date</emphasis> telling when the order was created</para></listitem>
				<listitem><para>The <emphasis role="strong">name of the product</emphasis> ordered (for simplicity sake, an order can only reference one product and it is its name that is stored)</para></listitem>
				<listitem><para>The <emphasis role="strong">quantity</emphasis> of items (of the product) ordered</para></listitem>
				<listitem><para>The <emphasis role="strong">total price</emphasis> of this order (that is quantity * unit price)</para></listitem>
			</itemizedlist>
		</para>

		<para>
			<classname>Shop</classname> is a class that can be used to do some operations related to <classname>Order</classname>. You can ask the shop to:
			<itemizedlist>
				<listitem><para><emphasis role="strong">Generate</emphasis> some random orders; it is useful to fill the database so that you can directly operate on it</para></listitem>
				<listitem><para><emphasis role="strong">Print out some field</emphasis> of all orders in the database</para></listitem>
				<listitem><para><emphasis role="strong">Load</emphasis> an order: Get the row and convert it to an instance of the class <classname>Order</classname></para></listitem>
				<listitem><para><emphasis role="strong">Save/Update/Delete</emphasis> an order (in the database)</para></listitem>
			</itemizedlist>
		</para>

		<para>Now, run the executable file <filename>NHibernateEg.Tutorial1A.exe</filename> to see all these operations in action.</para>
		<note>
			<title>Before running the application</title>
			<para>
				You need to configure your database. Open the file <filename>NHibernateEg.Tutorial1A.exe.config</filename>.
				By default, this application uses a database named "<emphasis>nhibernate</emphasis>" in Microsoft SQL Server 2000 (or MSDE).
			</para>
			<para>
				If you want to use a MySQL database, change the line:
				<literal>&lt;add key="Database" value="MSSQL" /&gt;</literal> to <literal>&lt;add key="Database" value="MySQL" /&gt;</literal>.
				And make sure that the files <filename>MySql.Data.dll</filename> and <filename>ICSharpCode.SharpZipLib.dll</filename> are in your path
				(they should already be in the current directory).
			</para>
			<para>
				You can also change the related <literal>Connection String</literal> if required. Set the <emphasis>value</emphasis> of:
				<literal>MSSQL.ConnectionString</literal> (for SQL Server) or <literal>MySQL.ConnectionString</literal> (for MySQL).
			</para>
		</note>

		<para>Note that you just have to create the database and configure its access; the application will fill it (after dropping the conflicting tables).</para>

		<para>When running the application, you should get something like:</para>
		<programlisting>
Application is starting...

Configuration of NHibernate...

Use database: &lt;MSSQL&gt;

NHibernate.Mapping.Attributes.HbmSerializer.Default.Serialize()...

new NHibernate.Tool.hbm2ddl.SchemaExport(cfg).Create()...
drop table SimpleOrder
create table SimpleOrder (
  Id INT IDENTITY NOT NULL,
   Date DATETIME null,
   Product NVARCHAR(255) not null,
   Quantity INT null,
   TotalPrice INT null,
   primary key (Id)
)

sessionFact = cfg.BuildSessionFactory();


Saving 3 aleatory orders...

3 orders found!
  Order N°1,  Date=2005-11-09 21:54:11Z,  Product=P1
  Order N°2,  Date=2005-11-09 21:54:11Z,  Product=P2
  Order N°3,  Date=2005-11-09 21:54:11Z,  Product=P3

Loading order N° 1...

Order N°1
 Date = wednesday 9 november 2005 20:54:11
 Product=P1 (updated),  Quantity=3,  TotalPrice=9

Update the order N° 1...

Save the order N° 0...

Change the time zone of all orders: n=25...
4 updated orders!

Deleting the order N° 2...

3 orders found!
  Order N°1,  Date=2005-11-10 22:54:11Z,  Product=P1 (updated)
  Order N°3,  Date=2005-11-10 22:54:11Z,  Product=P3
  Order N°4,  Date=2005-11-10 22:54:12Z,  Product=New

Application is closed!
</programlisting>

		<para>
			If you get an exception, read it to understand what the exact problem is
			(it is probably related to your database installation or your connection string).
		</para>
		<para>
			Study this output to understand what we will achieve in the next sections.
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-ADO.NET">
		<title>Quick review of ADO.NET methods</title>

		<para>If you are familiar with ADO.NET, you can quickly create the application we described following these steps:
			<itemizedlist>
				<listitem><para>Creation of tables in DB + Typed DataSet (can be generated - optional)</para></listitem>
				<listitem><para>Creation of DbConnection + DataAdapters + Commands (can be generated)</para></listitem>
				<listitem><para>Application lifecycle (=> implementation of CRUD operations)</para></listitem>
			</itemizedlist>
		</para>

		<para>This method has some drawbacks (which increase with the complexity of the software):
			<itemizedlist>
				<listitem><para>Lack of flexibility / hard to maintain</para></listitem>
				<listitem><para>Hard to do <emphasis role="strong">Object-Oriented Programming</emphasis> (OOP) on top of that</para></listitem>
				<listitem><para>Hard to separate the Domain Model from the DB</para></listitem>
			</itemizedlist>
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-ORM.NHibernate">
		<title>Using Object / Relational Mapping and NHibernate</title>

		<para>After the theoric presentation made in <xref linkend="Preface-ORM" />, we will focus on the practical aspect.</para>
		<para>
			An Object / Relational Mapping solution allows focusing on the object model when designing an application.
			The database is hidden by a persistence framework.
		</para>
		<para>
			While implementing the Shop, you will see that we almost never speak about the database (except to configure its access)
			and we will never manipulate tables/rows or SQL queries.
		</para>

		<para>You will discover the benefits of this technology when using it.</para>
		<para>
			The step zero is to create a Console Application and add the libraries:
			<filename>NHibernate.dll</filename>, <filename>log4net.dll</filename> and <filename>NHibernate.Mapping.Attributes.dll</filename> as references.</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-Order.NHMA">
		<title>Implementation of Order and introduction to NHibernate.Mapping.Attributes</title>

		<para>Now, we are going to implement the class <classname>Order</classname>. That is: Create the class, add the fields / properties and the methods.</para>

		<para>To manipulate the classes, NHibernate needs a mapping between these classes and the database tables. Here, we use the <emphasis role="strong">NHibernate.Mapping.Attributes</emphasis> to provide this mapping information.</para>
		<formalpara>
			<title>NHibernate.Mapping.Attributes uses .NET Attributes to define the mapping.</title>
			<para>
				Basically, for each element in your classes, you put the right attribute on it so that
				NHibernate will know how this element is mapped to its equivalent in the database.
				Each attribute has many properties used to specify how the mapping should work.
				Read NHibernate mapping reference documentation to understand their meaning.
			</para>
		</formalpara>

		<para>Here is the implementation of the class <classname>Order</classname>:</para>

		<section id="NHibernateEg.Tutorial1A-Order.Header">
			<title>The class header</title>
			<programlisting>
	[NHibernate.Mapping.Attributes.<classname>Class</classname>(<literal>Table="SimpleOrder"</literal>)]
	public class <classname>Order</classname>
	{
	}</programlisting>
			<para>
				The .NET attribute <classname>[Class]</classname> is used to tell to NHibernate that this is a mapped class.
				With <literal>Table="SimpleOrder"</literal>, we give the name of the table in which orders are stored.
			</para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Id">
			<title>The identifier and its generator</title>
			<programlisting>
	private int <methodname>_id</methodname> = 0;
	[NHibernate.Mapping.Attributes.<classname>Id</classname>(<literal>Name="Id"</literal>)]
		[NHibernate.Mapping.Attributes.<classname>Generator</classname>(1, <literal>Class="native"</literal>)]
	public virtual int <methodname>Id</methodname>
	{
		get { return _id; }
	}</programlisting>
			<para>
				The identifier is defined with the attribute <classname>[Id]</classname>.
				Don't forget to set its name (it can not be guessed...).
			</para><para>
				The identifier can be assigned by the database, the application (you) or NHibernate.
				Read the documentation for more details on these options.
				The attribute <classname>[Generator]</classname> is used to select one of these strategies.
				We will let the database choose the identifier, that's why we write <literal>Class="native"</literal>.
			</para><para>
				There is no <literal>set { ... }</literal> because the Id should never be changed
				(only NHibernate changes it when it is loaded/persisted).
			</para><para>
				As you can see, we have two attributes on this property (and there can be even more).
				<classname>[Generator]</classname> is indented to stress that it belongs to <classname>[Id]</classname>;
				and "1" (same as <literal>Position=1</literal>) tells that it comes after <classname>[Id]</classname> (which position is "0");
				.NET attributes are not automatically ordered.
			</para>
			<para></para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Properties">
			<title>The properties</title>
			<programlisting>
	private System.DateTime <methodname>_date</methodname> = System.DateTime.Now;
	private string <methodname>_product</methodname>;
	private int <methodname>_quantity</methodname>;
	private int <methodname>_totalPrice</methodname>;

	[NHibernate.Mapping.Attributes.<classname>Property</classname>]
	public virtual System.DateTime <methodname>Date</methodname>
	{
		get { return _date; }
	}

	[NHibernate.Mapping.Attributes.<classname>Property</classname>(<literal>NotNull=true</literal>)]
	public virtual string <methodname>Product</methodname>
	{
		get { return _product; }
		set { _product = value; }
	}

	[NHibernate.Mapping.Attributes.<classname>Property</classname>]
	public virtual int <methodname>Quantity</methodname>
	{
		get { return _quantity; }
		set { _quantity = value; }
	}

	[NHibernate.Mapping.Attributes.<classname>Property</classname>]
	public virtual int <methodname>TotalPrice</methodname>
	{
		get { return _totalPrice; }
		set { _totalPrice = value; }
	}</programlisting>
			<para>
				<classname>[Property]</classname> is used for fields that directly map to database's columns.
				The type of the property and the column should be compatible.
			</para><para>
				<literal>NotNull=true</literal> is written because the product's name should not be null.
				If you want to have nullable properties (for bool/int/float/DateTime/...),
				you can use the <emphasis role="strong">Nullables</emphasis> library
				(it is distributed in the NHibernateContrib package).
			</para><para>
				If you wonder how NHibernate can set read-only properties, you will see that
				<link linkend="NHibernateEg.Tutorial1A-Configuration">NHibernate is configured to use the private fields</link>.
				The advantage of this setting is that you can use the properties names in Queries
				and as NHibernate accesses directly to fields, it doesn't execute eventual business logic contained in the properties.
			</para><para>
				In your methods, you should not access these fields directly because they will not contain valid values in lazy loadable classes.
				Instead, you should use properties; they are <literal>virtual</literal> because it is required for entity lazy loading
				(it will be used in <xref linkend="NHibernateEg.Tutorial1B" />).
			</para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Methods">
			<title>The methods</title>
			<programlisting>
	public Order()
	{
	}

	public Order(string product, int unitPrice, int quantity)
	{
		this.Product = product;
		this.Quantity = quantity;
		this.ComputeTotalPrice(unitPrice);
	}

	public void ComputeTotalPrice(int unitPrice)
	{
		this.TotalPrice = unitPrice * this.Quantity;
	}

	public void ChangeTimeZone(int n)
	{
		this._date = this.Date.AddHours(n);
	}</programlisting>
			<para>
				There is nothing special here.
				As you can see, fields are never used; this is a good practice because it is required in lazy loadable classes.
			</para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Remarks">
			<title>Few remarks</title>
			<para>
				If you don’t set the name of the table/column (in the attributes) where the class/property is loaded/saved,
				NHibernate will guess that they have the same name.
			</para>
			<para>
				To fully understand NHibernate.Mapping.Attributes, you should read its documentation.
				And NHibernate documentation contains explanations for all mapping.
			</para>
			<para>
				As you read other articles/samples, you will discover that the mapping information is stored in <filename>.hbm.xml</filename> files.
				In fact, using attributes is a simpler and nicer way to generate this information (it is also far less verbose).
				Anyway, as you progress in your usage of NHibernate, you will probably need someday to hand-write these files.
			</para>
		</section>
	</section>


	<section id="NHibernateEg.Tutorial1A-Configuration">
		<title>Configuration of NHibernate (database and mapping)</title>

		<para>Before configuring NHibernate, there is a library you need to know: <emphasis role="strong">log4net</emphasis>.</para>
		<formalpara>
			<title>log4net is a logging system</title>
			<para>
				Basically, it receives log messages, filters them as you want
				and sends them wherever you want (in a file, on the console, in a database, as e-mail, etc.)
			</para>
		</formalpara>
		<para>
			Its configuration is in the file <filename>NHibernateEg.Tutorial1A.exe.config</filename>,
			in the section called <literal>&lt;log4net&gt;</literal>.
			You have to call one of the <methodname>log4net.Config.XmlConfigurator.Configure()</methodname>
			methods before using it; these methods read the configuration.
		</para><para>
			Finally, you put somewhere in your code:
			<programlisting>[assembly: log4net.Config.<classname>XmlConfigurator</classname>(<literal>Watch=true</literal>)]</programlisting>
			<literal>Watch=true</literal> tells to log4net to detect changes made on the configuration file at run-time
			(very useful to not have to restart your application...).
			For more information, go to <ulink url="http://log4net.sourceforge.net/">log4net website</ulink>.
		</para>

		<para>
			NHibernate needs some information to know how to communicate with the database:
			<itemizedlist>
				<listitem><para><literal>ConnectionProvider</literal>: <classname>NHibernate.Connection.DriverConnectionProvider</classname></para></listitem>
				<listitem><para><literal>Dialect</literal> and <literal>ConnectionDriver</literal>: they depend of your database.</para></listitem>
				<listitem><para><literal>ConnectionString</literal>: the string used to create a database connection.</para></listitem>
			</itemizedlist>
		</para>

		<para>The <literal>&lt;appSettings /&gt;</literal> section (in <filename>NHibernateEg.Tutorial1A.exe.config</filename>)
			makes it possible to switch from one database to another without changing a single line of code.
			Doing this with plain ADO.NET is not straightforward.
		</para>

		<para>
			Here is the code used to set this information:
			<programlisting>
	// Create the object that will hold the configuration settings
	// and fill it with the information to access to the Database
	<classname>NHibernate.Cfg.Configuration</classname> <methodname>cfg</methodname> = new NHibernate.Cfg.Configuration();
	cfg.SetProperty( NHibernate.Cfg.Environment.<methodname>ConnectionProvider</methodname>,
		<literal>"NHibernate.Connection.DriverConnectionProvider"</literal> );

	if("MSSQL" == database)
	{
		cfg.SetProperty(NHibernate.Cfg.Environment.<methodname>Dialect</methodname>, <literal>"NHibernate.Dialect.MsSql2000Dialect"</literal>);
		cfg.SetProperty(NHibernate.Cfg.Environment.<methodname>ConnectionDriver</methodname>, <literal>"NHibernate.Driver.SqlClientDriver"</literal>);
		cfg.SetProperty(NHibernate.Cfg.Environment.<methodname>ConnectionString</methodname>, <literal>connectionString</literal>);
	}
	else [...]</programlisting>
			Here, you can read the value of <literal>Dialect</literal> and <literal>ConnectionDriver</literal> for a Microsoft SQL Server 2000 database.
			These values are set with the method <methodname>SetProperty()</methodname>. They can also be set with a XML file.
		</para>

		<para>
			We extract the mapping information using NHibernate.Mapping.Attributes:
			<programlisting>
	System.IO.MemoryStream <methodname>stream</methodname> = new System.IO.MemoryStream(); // Where the information will be written
	// Ask to NHibernate to use fields instead of properties
	NHibernate.Mapping.Attributes.HbmSerializer.Default.<methodname>HbmDefaultAccess</methodname> = <literal>"field.camelcase-underscore"</literal>;<co id="NHEg.Tut1A.HbmDefaultAccess-co" linkends="NHEg.Tut1A.HbmDefaultAccess"/>
	// Gather information from this assembly (can also be done class by class)
	NHibernate.Mapping.Attributes.HbmSerializer.Default.<methodname>Serialize</methodname>( stream,
		System.Reflection.Assembly.<methodname>GetExecutingAssembly()</methodname> );<co id="NHEg.Tut1A.Serialize-co" linkends="NHEg.Tut1A.Serialize"/>
	stream.Position = 0;
	<literal>cfg.AddInputStream(stream);</literal><co id="NHEg.Tut1A.AddInputStream-co" linkends="NHEg.Tut1A.AddInputStream"/> // Send the Mapping information to NHibernate Configuration
	stream.Close();</programlisting>
			<calloutlist>
				<callout arearefs="NHEg.Tut1A.HbmDefaultAccess-co" id="NHEg.Tut1A.HbmDefaultAccess"><para>
					With this setting, NHibernate will convert the name of the property in the camel case
					and will add an underscore before to get the name of the field that hold this data.
					If the field is private, it will use the reflection (so make sure that the application's security level allows this).
				</para></callout>
				<callout arearefs="NHEg.Tut1A.Serialize-co" id="NHEg.Tut1A.Serialize"><para>
					Here, NHibernate.Mapping.Attributes uses the .NET reflection to find all classes (in the ExecutingAssembly)
					with the attribute <classname>[Class]</classname> and fill the stream with information about these classes.
				</para></callout>
				<callout arearefs="NHEg.Tut1A.AddInputStream-co" id="NHEg.Tut1A.AddInputStream"><para>
					Once the stream is filled, we rewind it and send it to the NHibernate Configuration instance.
					It will parse its XML content to gather all the information NHibernate will need to manipulate your classes.
				</para></callout>
			</calloutlist>
		</para>

		<para>
			Now, we use a wonderful tool: <emphasis role="strong">SchemaExport</emphasis>:
			<programlisting>new NHibernate.Tool.hbm2ddl.<classname>SchemaExport</classname>(cfg).<methodname>Create</methodname>(true, true);</programlisting>
			Here, we create an instance of <classname>SchemaExport</classname> and we directly call the method <methodname>Create()</methodname>.
			It uses all the provided information (in the configuration instance) to generate and run a script
			that will create the tables and relationships in the database to hold the mapped classes.
			Note that it will fail to drop a table if this table has a reference that doesn’t exist in the mapping; in this case, you must drop this table manually.
		</para>

		<para>
			Finally, we create the <classname>SessionFactory</classname>: (explanation in the next section)
			<programlisting>_sessionFact = cfg.BuildSessionFactory();</programlisting>
			Note thate the <emphasis role="strong">_sessionFact</emphasis> is an instance of the class <classname>Shop</classname>
			that will be destroyed only when the Shop instance is destroyed.
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-Persistence">
		<title>Persistence API</title>

		<para>Before digging into NHibernate operations, there are some concepts that need to be explained:</para>

		<formalpara>
			<title>The notion of "Entity"</title>
			<para>
				In these articles, an entity is simply a mapped class.
				It implies that NHibernate is aware of this class and can manipulate it.
			</para>
		</formalpara>

		<para>
			The main interface used to manipulate entities is <emphasis role="strong">ISession</emphasis>
			(full name: <classname>NHibernate.ISession</classname>).
		</para>
		<para>
			A session is created by an <emphasis role="strong">ISessionFactory</emphasis>.
			You need <emphasis role="strong">one</emphasis> ISessionFactory for each database
			(which is generally created at the initialization of the application as it is the case here).
			Its implementation is thread-safe and exception-proof, so that it can live as long as your application is running.
		</para>
		<para>
			For sessions, you should use the <emphasis role="strong">session-per-request pattern</emphasis>;
			that is one session for each user request.
			This is recommended because they are not exception-proof (nor thread-safe).
			If an exception is thrown, you should rollback the transaction and close the session (don’t try to recover it).
		</para>

		<para>
			The classic usage of a session (and its transaction) is:
			<programlisting>
	NHibernate.ISession session = null;
	NHibernate.ITransaction transaction = null;
	try
	{
		session = _sessionFact.<methodname>OpenSession()</methodname>;
		transaction = session.<methodname>BeginTransaction()</methodname>;

		// CRUD operations here (with the session)

		transaction.<methodname>Commit()</methodname>;
	}
	catch
	{
		if(transaction != null)
			transaction.<methodname>Rollback()</methodname>;
		throw;
	}
	finally
	{
		if(session != null)
			session.<methodname>Close()</methodname>;
	}</programlisting>
			As you can read in this code, we create the session, then its transaction.
			We use the session to do some CRUD operations; finally, we commit the changes and close the session (rollback if any exception is thrown).
		</para>
		<para>
			NHibernate transactions behave like ADO.NET transactions.
			The transaction is tightly coupled with the session but it is optional (mainly when you just want to run a SELECT). In this case, you can write:
			<programlisting>
	<literal>using</literal>(NHibernate.ISession session = _sessionFact.<methodname>OpenSession()</methodname>)
	{
		// Retrieve data here (with the session)
	}</programlisting>
			<literal>using()</literal> will automatically close the session.
		</para>

		<para>
			An entity has a <emphasis role="strong">state</emphasis> which can change:
			The state you implicitly know is <emphasis role="strong">transient</emphasis>.
			When you create an instance of a class, this instance is transient.
		</para>
		<para>
			Once you send this instance to a session (to save/update it...), this instance becomes <emphasis role="strong">persisted</emphasis>.
			At this level, the session has this instance in its cache.
		</para>
		<para>
			If you delete this instance, it is obviously not destroyed from the memory;
			the session will delete its row in the database and will remove it from its cache
			(which means that it becomes transient again).
			Note that an entity can not be attached to two opened sessions at the same time.
		</para>
		<para>
			Finally, when an instance is persisted and the session which persisted it is closed,
			this instance became <emphasis role="strong">detached</emphasis>.
			The difference with "transient" is that there might be some useful information
			that are hidden in this instance and can be used by another session.
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-CRUD">
		<title>CRUD operations</title>

		<para>Now, we will use the session to do some basic CRUD operations (that is Create, Retrieve, Update and Delete).</para>

		<para>For each operation, a method will be shown and explained.</para>


		<section id="NHibernateEg.Tutorial1A-CRUD.Create">
			<title>CREATE: Save</title>
			<para>
				<emphasis role="strong">Implementation of the method:
				<classname>Shop</classname>.<methodname>GenerateRandomOrders()</methodname></emphasis>
			</para>
			<programlisting>
	public void GenerateRandomOrders(int n)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;
	
		System.Console.Out.WriteLine("\nSaving " + n + " aleatory orders...");
		try
		{
			session = _sessionFact.OpenSession();
			transaction = session.BeginTransaction();
	
			for(int i=0; i&lt;n; i++)
			{
				Order o = new Order();
	
				o.Product = "P" + (i+1).ToString();
				o.Quantity = n - i;
				o.ComputeTotalPrice(i * 10 + n);
	
				<literal>session.Save(o);</literal>
			}
	
			// Commit modifications (Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error: we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>In this method, orders are randomly created and filled. Then, the method <methodname>session.Save()</methodname> is used to save them.</para>
		</section>


		<section id="NHibernateEg.Tutorial1A-CRUD.Retrieve">
			<title>RETRIEVE: Query and Load/Get</title>
			<para>
				To retrieve entities, NHibernate has two query APIs:
				<itemizedlist>
					<listitem><para>The <emphasis role="strong">Hibernate Query Language</emphasis> (<emphasis role="strong">HQL</emphasis>) is a language similar to SQL but "object-oriented".</para></listitem>
					<listitem><para>The <emphasis role="strong">Criteria API</emphasis>: Use classes to express your query.</para></listitem>
				</itemizedlist>
				These APIs return as result an <classname>IList</classname> which contains all the items matching the criteria.
			</para>

			<para>
				When you need to load an entity (knowing its identifier), you can either use
				<methodname>session.Load()</methodname> or <methodname>session.Get()</methodname>;
				send the type and the identifier of the entity to load it.
			</para>
			<para>
				<methodname>session.Load()</methodname> throws an exception
				if there is no entity in the database with this identifier and
				<methodname>session.Get()</methodname> simply returns <emphasis role="strong">null</emphasis> in this case.
				The session runs a query to retrieve the row, builds an instance, fills and returns it.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method:
				<classname>Shop</classname>.<methodname>WriteAllOrders()</methodname></emphasis>
			</para>
			<programlisting>
	public void WriteAllOrders()
	{
		using(NHibernate.ISession session = _sessionFact.OpenSession())
		{
			System.Collections.IList result = session.<methodname>Find</methodname>(<literal>"select o.Id, o.Date, o.Product from Order o"</literal>);
	
			System.Console.Out.WriteLine("\n" + result.Count + " orders found!");
			foreach(System.Collections.IList l in result)
				System.Console.Out.WriteLine("  Order N°"
					+ l[0] + ",  Date=" + ((System.DateTime)l[1]).ToString("u")
					+ ",  Product=" + l[2]);
		} // finally { session.Close(); }	is done by using()
	}</programlisting>
			<para>
				As you can see, there is no transaction here (needless) and <literal>using()</literal> will close the session at the end.
				The HQL query ran here is "<literal>select o.Id, o.Date, o.Product from Order o</literal>".
				This query is identical to what can be written in SQL:
				We ask the list of some items (the Id, Date and Product) in Order's table.
				These items are stored in an <classname>IList</classname> which means that we get an IList containing ILists.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method:
				<classname>Shop</classname>.<methodname>LoadOrder()</methodname></emphasis>
			</para>
			<programlisting>
	public Order LoadOrder(int id)
	{
		System.Console.Out.WriteLine("\nLoading order N° " + id + "...");
		using(NHibernate.ISession session = _sessionFact.OpenSession())
			return <literal>session.Load(typeof(Order), id)</literal> as Order;
		// finally { session.Close(); }	is done by using()
	}</programlisting>
			<para>
				This method uses <methodname>session.Load()</methodname> because
				we know that it would be <emphasis role="strong">exceptional</emphasis>
				that the entity to load doesn’t exist.
			</para>
		</section>


		<section id="NHibernateEg.Tutorial1A-CRUD.Update">
			<title>UPDATE: SaveOrUpdate / Save / Update</title>
			<para></para>

			<para>
				<emphasis role="strong">Implementation of the method:
				<classname>Shop</classname>.<methodname>Save()</methodname></emphasis>
			</para>
			<programlisting>
	public void Save(Order o)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;

		// That's how the Session decide to save or to update; set NHMA.Id(UnsavedValue=x) to replace 0
		System.Console.Out.Write("\n"  +  (o.Id == 0  ?  "Save"  :  "Update"));
		System.Console.Out.WriteLine(" the order N° " + o.Id + "...");
		try
		{
			session = _sessionFact.OpenSession();
			transaction = session.BeginTransaction();

			// NHibernate Session will automatically find out if it has to build an INSERT or an UPDATE
			<literal>session.SaveOrUpdate(o);</literal>

			// Commit modifications (=> Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error => we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>
				This method uses a particular technique to issue INSERT or UPDATE commands:
				An identifier has an unsaved value which is by default, the value that it takes when it is created
				(an integer takes the value 0 at its creation).
				You can set <literal>NHibernate.Mapping.Attributes.Id(UnsavedValue=?)</literal> to replace the unsaved value.
				So a new entity will have the unsaved value as identifier and the session will know that it needs to insert this entity.
				Refer to the documentation to see how you can customize this behavior even more.
				There are still the methods <methodname>session.Save()</methodname> and <methodname>session.Update()</methodname> if you need them.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method:
				<classname>Shop</classname>.<methodname>ChangeTimeZone()</methodname></emphasis>
			</para>
			<programlisting>
	public void ChangeTimeZone(int n)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;

		System.Console.Out.WriteLine("\nChange the time zone of all orders: n=" + n + "...");
		try
		{
			session = _sessionFact.OpenSession();
			transaction = session.BeginTransaction();

			System.Collections.IList commandes = <literal>session.CreateCriteria(typeof(Order)).List();</literal>
			// == <literal>session.Find("from Order");</literal>
			foreach(Order o in commandes)
				o.ChangeTimeZone(n);
			// It is useless to call Update(), the Session will automatically
			// detect modified entities (as long as it loaded them)
			System.Console.Out.WriteLine(commandes.Count + " updated orders!");

			// Commit modifications (=> Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error => we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>
				Here, we load all orders using: <programlisting>session.<literal>CreateCriteria(typeof(Order))</literal>.List()</programlisting>
				Equivalent to: <programlisting>session.Find(<literal>"from Order"</literal>)</programlisting>
				"select" is not needed when you want entities (in simple queries), but you can write it like this:
				<programlisting>session.Find(<literal>"select o from Order o"</literal>)</programlisting>
			</para>
			<para>
				Once loaded, these entities are kept in the session cache. This means that you don’t need to save them again.
				When doing <methodname>transaction.Commit()</methodname>; the session will browse its cache to detect changed entities and it will persist them.
				This feature is called <emphasis role="strong">transparent persistence</emphasis>.
			</para>
		</section>


		<section id="NHibernateEg.Tutorial1A-CRUD.Delete">
			<title>DELETE: Delete(HQL) and Delete(Entity)</title>
			<para>
				There are two ways to delete entities:
				You can either run a HQL query or send an entity for deletion.
			</para>
			<para>
				With HQL, NHibernate will first load all matching entities (to update its caches...) and then,
				it will delete them (and delete linked entities by cascade if needed).
				If you already have an entity, you can call <methodname>session.Delete(entity)</methodname>.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method:
				<classname>Shop</classname>.<methodname>Delete()</methodname></emphasis>
			</para>
			<programlisting>
	public void Delete(int id)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;

		System.Console.Out.WriteLine("\nDeleting the order N° " + id + "...");
		try
		{
			session = _sessionFact.OpenSession();
			transaction = session.BeginTransaction();

			session.<methodname>Delete</methodname>(<literal>"from Order o where o.Id = :Id"</literal>, id, <methodname>NHibernate.NHibernateUtil.Int32</methodname>);

			// Commit modifications (=> Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error => we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>
				The new element here is the usage of <emphasis role="strong">parameter</emphasis>:
				an object (the id) and the descriptor of its type (<methodname>NHibernate.NHibernateUtil.Int32</methodname>).
			</para>
			<para>
				You can also write:
				<programlisting>session.Delete(<literal>"from Order o where o.Id = " + id</literal>);</programlisting>
				But it is not recommended to take this habit.
				Using parameters prevents some SQL injection attacks and escapes invalid characters.
				And you can also get slightly better performances.</para>
		</section>
	</section>


	<section id="NHibernateEg.Tutorial1A-Conclusion">
		<title>Conclusion</title>

		<para>
			In this tutorial, we designed a simple shop, we implemented its order class, we configured NHibernate
			and implemented the Shop's methods (doing CRUD operations).
		</para>

		<para>
			The most obvious advantage of using an ORM (for beginners) is the simplicity when doing CRUD operations.
			When you are familiar with the API, you can load, save, update and delete entities without any knowledge of the underlining database;
			you don’t even need to know SQL. But this knowledge is still important if you want get the best performance.
		</para>

		<para>
			Another more important advantage is that your entities don’t even know that they are ever persisted;
			which can be useful in complex applications.
			Persistence becomes an external service (which is not intrusive).
		</para>

		<para>Finally, you can design your application with OOP in mind and then create a database that can keep your entities.</para>
		<para>
			But NHibernate is also impressive when dealing with legacy database.
			You can take a classic relational database and map it to your object-oriented entities.
		</para>

		<para>
			You have to understand that if DataSet is not the perfect answer to every problem, ORM is neither perfect in every situation.
			Reporting and batch processing are situations where DataSet and DataReader might perform better.
			And it is probably simpler to use them in straightforward applications.
		</para>

		<para>
			Now, I suggest you to try to do a Console Application similar to this one
			without looking at the tutorial/code too often. You may also try new things.
			After that, you will have a better understanding and memorize more information.
		</para>

		<para>
			A tool that you should really try is <ulink url="http://www.ayende.com/projects/nhibernate-query-analyzer.aspx">NHibernate Query Analyzer</ulink>.
			With it, you can edit configuration (<filename>hibernate.cfg.xml</filename>) and mapping (<filename>.hbm.xml</filename>) files.
			You can also easily run HQL queries after setting up the configuration. To see it in action, download the flash videos available on its web site.
		</para>

		<para>
			You can find more sample and articles in the
			<ulink url="http://wiki.nhibernate.org/display/NH/Documentation">NHibernate Documentation</ulink>.
		</para>

		<para>
			And if you want to discuss about this tutorial, use
			<ulink url="http://nhibernate.sourceforge.net/forum/viewforum.php?f=9">this NHibernate forum</ulink>.
		</para>
	</section>

</chapter>
